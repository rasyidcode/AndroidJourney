package me.jamilalrasyidis.learningcustomcamera

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.Matrix
import android.graphics.Point
import android.graphics.RectF
import android.graphics.SurfaceTexture
import android.hardware.camera2.CameraCaptureSession
import android.hardware.camera2.CameraDevice
import android.hardware.camera2.CaptureRequest
import android.os.Bundle
import android.os.Handler
import android.os.HandlerThread
import android.util.Log
import android.util.Size
import android.view.*
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import java.lang.RuntimeException
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit
import kotlin.math.max

class Camera2Fragment : Fragment() {

    /**
     * The current state of camera state for taking picture
     */
    private val state: Int = STATE_PREVIEW
    /**
     * A {@link Semaphore} to prevent the app from exiting before closing the camera.
     */
    private val cameraOpenCloseLock: Semaphore = Semaphore(1)
    /**
     * A {@link CameraPictureSession } for camera preview
     */
    private lateinit var captureSeasson: CameraCaptureSession
    /**
     * A reference to the opened {@link CameraDevice}
     */
    private var cameraDevice: CameraDevice? = null
    /**
     * ID of the current {@link CameraDevice}
     */
    private lateinit var cameraId: String
    /**
     * The {@link android.util.Size} of camera preview.
     */
    private lateinit var previewSize: Size
    /**
     * Orientation of the camera sensor
     */
    private var sensorOrientation: Int = 0
    /**
     * An {@link ScalingTextureView} for camera preview
     */
    private lateinit var textureView: ScalingTextureView
    /**
     * {@link CaptureRequest.Builder} for camera preview.
     */
    private lateinit var previewRequestBuilder: CaptureRequest.Builder
    /**
     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder
     */
    private lateinit var previewRequest: CaptureRequest
    /**
     * An additional thread for running tasks that shouldn't block the UI
     */
    private lateinit var backgroundThread: HandlerThread
    /**
     * A {@link Handler} for running takss in the background.
     */
    private lateinit var backgroundHandler: Handler

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(R.layout.fragment_camera2, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        Log.d(TAG, "onViewCreated: created view")

        textureView = view.findViewById(R.id.texture)
        setMaxSizes()
    }

    private fun setMaxSizes() {
        val displaySize = Point()
        activity!!.windowManager.defaultDisplay.getSize(displaySize)
        SCREEN_WIDTH = displaySize.x
        SCREEN_HEIGHT = displaySize.y

        Log.d(TAG, "setMaxSizes: screen width: $SCREEN_WIDTH")
        Log.d(TAG, "setMaxSizes: screen height: $SCREEN_HEIGHT")
    }

    private val surfaceTextureListener: TextureView.SurfaceTextureListener = object : TextureView.SurfaceTextureListener {
        override fun onSurfaceTextureSizeChanged(
            surface: SurfaceTexture?,
            width: Int,
            height: Int
        ) {
            Log.d(TAG, "onSurfaceTextureSizeChanged: w: $width, h: $height")
            configureTransform(width, height)
        }

        override fun onSurfaceTextureUpdated(surface: SurfaceTexture?) {}

        override fun onSurfaceTextureDestroyed(surface: SurfaceTexture?): Boolean = true

        override fun onSurfaceTextureAvailable(surface: SurfaceTexture?, width: Int, height: Int) {
            Log.d(TAG, "onSurfaceTextureAvailable: w: $width, h: $height")
            openCamera(width, height)
        }
    }

    private fun configureTransform(viewWidth: Int, viewHeight: Int) {
        val acty = activity!!
        val rotation = acty.windowManager.defaultDisplay.rotation
        val matrix = Matrix()
        val viewRect = RectF(0.toFloat(), 0.toFloat(), viewWidth.toFloat(), viewHeight.toFloat())
        Log.d(TAG, "configureTransform: viewWidth: $viewWidth, viewHeight: $viewHeight")
        Log.d(TAG, "configureTransform: previewWidth: ${previewSize.width}, previewHeight: ${previewSize.height}")
        val bufferRect = RectF(0.toFloat(), 0.toFloat(), previewSize.height.toFloat(), previewSize.width.toFloat())
        val centerX = viewRect.centerX()
        val centerY = viewRect.centerY()

        if (rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270) {
            Log.d(TAG, "configureTransform: rotating from 90 or 270")
            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY())
            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL)
            val scale = max(viewHeight / previewSize.height, viewWidth / previewSize.width)
            matrix.postScale(scale.toFloat(), scale.toFloat(), centerX, centerY)
            matrix.postRotate((90 * (rotation - 2)).toFloat(), centerX, centerY)
        } else if (rotation == Surface.ROTATION_180) {
            Log.d(TAG, "configureTransform: rotating 180.")
            matrix.postRotate(180.toFloat(), centerX, centerY)
        }

        textureView.setTransform(matrix)
    }

    private fun openCamera(width: Int, height: Int) {
        if (ContextCompat.checkSelfPermission(activity!!, Manifest.permission.CAMERA)
                != PackageManager.PERMISSION_GRANTED) {
//            requestCameraPermission()
            return
        }

//        setupCameraOutputs(width, height)
        configureTransform(width, height)
        val acty = activity!!
        val manager = acty.getSystemService(Context.CAMERA_SERVICE)
//        try {
//            if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
//                throw RuntimeException("Time out waiting to lock camera opening.")
//            }
//            manager.openCamera(cameraId, stateCallback, backgroundHandler)
//        } catch ()
    }

    /**
     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.
     */
    private val stateCallback: CameraDevice.StateCallback = object : CameraDevice.StateCallback() {
        override fun onOpened(camera: CameraDevice) {
            cameraOpenCloseLock.release()
            cameraDevice = camera
//            createCameraPreviewSession()
        }

        override fun onDisconnected(camera: CameraDevice) {
            cameraOpenCloseLock.release()
            cameraDevice?.close()
            cameraDevice = null
        }

        override fun onError(camera: CameraDevice, error: Int) {
            Log.d(TAG, "onError : $error")
            cameraOpenCloseLock.release()
            cameraDevice?.close()
            cameraDevice = null
            val acty = activity!!
            acty.finish()
        }

    }

    companion object {
        const val TAG = "Camera2Fragment"
        const val REQUEST_CAMERA_PERMISSION = 1
        const val FRAGMENT_DIALOG = "dialog"

        /* Camera state: Showing camera preview. */
        const val STATE_PREVIEW = 0

        fun newInstance() : Camera2Fragment {
            return Camera2Fragment()
        }

        /**
         * Max preview width that is guaranteed by Camera2 API
         */
        private const val MAX_PREVIEW_WIDTH = 1920
        /**
         * Max preview height that is guaranteed by Camera2 API
         */
        private var MAX_PREVIEW_HEIGHT = 1080
        private var SCREEN_WIDTH = 0
        private var SCREEN_HEIGHT = 0
        private var ASPECT_RATIO_ERROR_RANGE: Float = 0.1f
    }
}